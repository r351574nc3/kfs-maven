# The property value (for datasource.ojb.platform) which indicates a MySQL database
mysql.ojb.platform=MySQL
# The property value (for datasource.ojb.platform) which indicates an Oracle database
oracle.ojb.platform=Oracle9i
# Default to oracle if not specified elsewhere
datasource.ojb.platform=${oracle.ojb.platform}

mysql.driver.class=com.mysql.jdbc.Driver
oracle.driver.class=oracle.jdbc.OracleDriver
p6spy.driver.class=com.p6spy.engine.spy.P6SpyDriver

# Special OJB classes for handling sequences
mysql.ojb.sequence.manager=org.apache.ojb.broker.platforms.KualiMySQLSequenceManagerImpl
oracle.ojb.sequence.manager=org.apache.ojb.broker.util.sequence.SequenceManagerNextValImpl

# Rice classes for handling Differences between database versions
mysql.server.datasource.platform=org.kuali.rice.core.database.platform.MySQLDatabasePlatform
oracle.server.datasource.platform=org.kuali.rice.core.database.platform.OracleDatabasePlatform

# specify the number of connections in the pool
datasource.pool.size=50

# The maximum number of connections the persistence broker pool will handle
# When running with Embedded Rice, this can be the same as the datasource.pool.size property.
# When running with a standalone Rice server (to which this server will have direct database connections),
# this property must be the sum of the datasource.pool.size and rice.server.datasource.pool.size
ojb.persistencebroker.pool.maxactive=${datasource.pool.size}

# specify the number of prepared statements cached per connection
datasource.maximum.cached.preparedstatements=25
# specify the connection timeout
datasource.connection.timeout=100000
# used in datasource configuration to force transactions to timeout after they've run too long
transaction.timeout=${datasource.connection.timeout}

# specify the query used to validate connections as they're pulled from the pool
datasource.validating.query=select 1 from dual

# 0: no check, the connection is taken from the pool without any verification
# 1: test if the connection is closed or not, if it is closed, another connection is tested, until we can return a valid connection
# 2: a test is made on the connection with a jdbc statement string. You need to set this string with setJdbcTestStmt(string test) method on StandardXAPoolDataSource object or StandardPoolDataSource object if you use this one. In a lot of case, you can use "select 1" to test your connection.
# 3: test all the unused connections inside the pool, and verify if a connection is closed. If a connection is closed, the pool removes it and creates a new one if needed.
# 4: verify all the unused connections from the pool with a jdbc statement string (see level 2, to set up a jdbc statement string).
datasource.xapool.connection.test.mode=2
